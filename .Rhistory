makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
mc<-NULL
set<-function(y){
x<<-y
mc<<-NULL
}
get<-function() x
setmatrix<-function(solve) mc<<- solve
getmatrix<-function() mc
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
mc<-x$getmatrix()
if(!is.null(mc)){
message("getting cached data")
return(m)
}
matrix<-x$get()
mc<-solve(matrix, ...)
x$setmatrix(mc)
mc
}
# Matrix inversion is usually a costly computation and there may be some benefit
# to caching the inverse of a matrix rather than compute it repeatedly. The
# following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
mc<-NULL
set<-function(y){
x<<-y
mc<<-NULL
}
get<-function() x
setmatrix<-function(solve) mc<<- solve
getmatrix<-function() mc
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
mc<-x$getmatrix()
if(!is.null(mc)){
message("getting cached data")
return(m)
}
matrix<-x$get()
mc<-solve(matrix, ...)
x$setmatrix(mc)
mc
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
x$get()
x
cacheSolve(m)
cacheSolve(m)
cacheSolve(mc)
x
x$get()
mc$get()
# Matrix inversion is usually a costly computation and there may be some benefit
# to caching the inverse of a matrix rather than compute it repeatedly. The
# following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
mc<-NULL
set<-function(y){
x<<-y
mc<<-NULL
}
get<-function() x
setmatrix<-function(solve) mc<<- solve
getmatrix<-function() mc
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
mc<-x$getmatrix()
if(!is.null(mc)){
message("getting cached data")
return(mc)
}
matrix<-x$get()
mc<-solve(matrix, ...)
x$setmatrix(mc)
mc
}
makeCacheMatrix(x)
View(x)
# Matrix inversion is usually a costly computation and there may be some benefit
# to caching the inverse of a matrix rather than compute it repeatedly. The
# following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
mc<-NULL
set<-function(y){
x<<-y
mc<<-NULL
}
get<-function() x
setmatrix<-function(solve) mc<<- solve
getmatrix<-function() mc
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
mc<-x$getmatrix()
if(!is.null(mc)){
message("getting cached data")
return(mc)
}
matrix<-x$get()
mc<-solve(matrix, ...)
x$setmatrix(mc)
mc
}
x = rbind(c(1, -1/4), c(-1/4, 1))
makecachematrix(x)
makeCacheMatrix(x)
m = makeCacheMatrix(x)
m$get()
x
cacheSolve(m)
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
source('~/GitHub/ProgrammingAssignment2/cachematrix.R')
